#!/usr/bin/env python3
"""
FreeWorld FPDF2 PDF Generator - Clean, Beautiful Job Cards
NO ReportLab dependencies - Pure FPDF2 implementation
"""

import pandas as pd
from fpdf import FPDF
from fpdf.enums import XPos, YPos
from datetime import datetime
import os
import sys
import re

try:
    from link_tracker import LinkTracker
except ImportError:
    try:
        from .link_tracker import LinkTracker
    except ImportError:
        # Fallback if link tracker not available
        class LinkTracker:
            def create_tracked_link(self, url, job_id):
                return url
            def create_link(self, url, job_id):
                return url

def prepare_pdf_data(job_row):
    """
    Single source of truth for PDF field mapping from canonical schema.
    Takes a job row/dict and returns standardized fields for PDF generation.
    """
    return {
        # Core job info - prefer source fields, fallback to norm
        'job_title': job_row.get('source.title') or job_row.get('norm.title', 'Job Title'),
        'company': job_row.get('source.company') or job_row.get('norm.company', 'Company'),
        'location': job_row.get('source.location_raw') or job_row.get('norm.location', 'Location'),
        
        # AI classification results
        'summary': job_row.get('ai.summary') or job_row.get('source.description') or job_row.get('norm.description', 'Great opportunity for CDL drivers.'),
        'match': job_row.get('ai.match', ''),
        'reason': job_row.get('ai.reason', ''),
        'route_type': job_row.get('ai.route_type', 'Unknown'),
        'fair_chance': job_row.get('ai.fair_chance', ''),
        'endorsements': job_row.get('ai.endorsements', 'none_required'),

        # Career pathway fields (new schema)
        'career_pathway': job_row.get('ai.career_pathway', ''),
        'training_provided': job_row.get('ai.training_provided', False),

        # URLs - priority order with NaN protection
        'apply_url': (
            str(job_row.get('meta.tracked_url') or '').replace('nan', '') or
            str(job_row.get('apply_url') or '').replace('nan', '') or
            str(job_row.get('source.url') or '').replace('nan', '') or
            ''
        ),
        'tracked_url': job_row.get('meta.tracked_url', ''),
        
        # Salary info
        'salary': job_row.get('norm.salary_display', ''),
        
        # Identifiers
        'job_id': job_row.get('id.job', 'unknown'),
        'source': job_row.get('id.source', 'unknown')
    }

class FreeWorldJobCardFPDF(FPDF):
    """FPDF2-based job card generator with full-page layout control"""
    
    def __init__(self):
        super().__init__(orientation='P', unit='pt', format=(375, 750))  # Mobile dimensions
        self.set_margins(0, 0, 0)  # No margins - full page usage
        self.set_auto_page_break(False)  # Disable auto page breaks for full control
        
        # FreeWorld Brand Colors (RGB values)
        self.fw_roots = (0, 71, 81)          # #004751 - Primary teal for titles
        self.fw_freedom_green = (205, 249, 92)  # #CDF95C - Light green for buttons
        self.fw_bright_green = (0, 255, 0)   # #00FF00 - Bright green for emphasis
        self.fw_midnight = (25, 25, 49)      # #191931 - Dark text
        self.fw_visionary_violet = (89, 60, 188) # #593CBC - Visionary violet for possible fits
        self.fw_horizon_grey = (244, 244, 244) # #F4F4F4 - Horizon grey for apply section background
        self.fw_card_border = (204, 204, 204)  # #CCCCCC - Border
        self.fw_card_bg = (250, 250, 250)   # #FAFAFA - Background
        
        # Initialize link tracker
        self.link_tracker = LinkTracker()
        
        # Try to load custom fonts
        self._load_custom_fonts()
    
    def _sanitize_text(self, text):
        """Sanitize text to remove problematic Unicode characters"""
        if not text:
            return ""
        
        # Convert to string and handle common problematic characters
        text = str(text)
        replacements = {
            '‚Äì': '-',  # Em dash to hyphen
            '‚Äî': '-',  # En dash to hyphen  
            '"': '"',  # Smart quotes to regular quotes
            '"': '"',
            ''': "'",
            ''': "'",
            '‚Ä¶': '...',  # Ellipsis to three dots
            '¬Æ': '(R)', 
            '‚Ñ¢': '(TM)',
            '¬©': '(C)'
        }
        
        for old, new in replacements.items():
            text = text.replace(old, new)
        
        # Remove any remaining non-ASCII characters
        text = re.sub(r'[^\x00-\x7F]+', ' ', text)
        
        return text.strip()
    
    def _estimate_text_lines(self, text, width):
        """Estimate how many lines the text will take when wrapped"""
        if not text:
            return 1
        
        # Get the current font's character width (approximate)
        avg_char_width = self.get_string_width('M')  # Use 'M' as average character width
        chars_per_line = int(width / avg_char_width)
        
        if chars_per_line <= 0:
            return 1
        
        # Simple word wrap estimation
        words = text.split()
        current_line_length = 0
        lines = 1
        
        for word in words:
            if current_line_length + len(word) + 1 > chars_per_line:  # +1 for space
                lines += 1
                current_line_length = len(word)
            else:
                current_line_length += len(word) + 1
        
        return max(1, lines)
    
    def _load_custom_fonts(self):
        """Load Outfit fonts from static directory"""
        outfit_regular = os.path.join(os.path.dirname(__file__), "Outfit", "static", "Outfit-Regular.ttf")
        outfit_bold = os.path.join(os.path.dirname(__file__), "Outfit", "static", "Outfit-Bold.ttf")
        
        # Try to load static Outfit fonts (no fvar issues)
        if os.path.exists(outfit_regular) and os.path.exists(outfit_bold):
            try:
                self.add_font('Outfit', '', outfit_regular, uni=True)
                self.add_font('Outfit', 'B', outfit_bold, uni=True)
                print(f"‚úÖ Loaded static Outfit fonts (Regular + Bold)")
                self.custom_font = "Outfit"
                self.custom_font_bold = "Outfit"
                return
            except Exception as e:
                print(f"‚ö†Ô∏è Static Outfit fonts failed: {e}")
        
        # Fallback to Palatino if Outfit fails
        try:
            palatino_paths = [
                "/System/Library/Fonts/Palatino.ttc",  # macOS
                "/System/Library/Fonts/Palatino.ttf"   # macOS alternative
            ]
            
            for palatino_path in palatino_paths:
                if os.path.exists(palatino_path):
                    try:
                        self.add_font('Palatino', '', palatino_path, uni=True)
                        
                        # Try to add bold variant
                        bold_path = palatino_path.replace('.ttc', '-Bold.ttc').replace('.ttf', '-Bold.ttf')
                        if os.path.exists(bold_path):
                            self.add_font('Palatino', 'B', bold_path, uni=True)
                            print(f"‚úÖ Loaded Palatino + Bold from system")
                            self.custom_font = "Palatino"
                            self.custom_font_bold = "Palatino"
                        else:
                            print(f"‚úÖ Loaded Palatino (regular only) from system - using Helvetica for bold")
                            self.custom_font = "Palatino"
                            self.custom_font_bold = "Helvetica"
                        return
                    except Exception as e:
                        print(f"‚ö†Ô∏è Failed to load Palatino: {e}")
                        continue
            
            # Final fallback
            print("‚ÑπÔ∏è Using Helvetica as final fallback")
            self.custom_font = "Helvetica"
            self.custom_font_bold = "Helvetica"
            
        except Exception as e:
            print(f"‚ö†Ô∏è Font loading error: {e}")
            self.custom_font = "Helvetica"
            self.custom_font_bold = "Helvetica"
    
    def _set_font(self, style='', size=12):
        """Set Outfit font with emoji support"""
        if style == 'B':
            self.set_font(self.custom_font_bold, 'B', size)
        else:
            self.set_font(self.custom_font, style, size)
    
    def _write_text_with_emojis(self, x, y, text, style='', size=12, color=None):
        """Write text that may contain emojis"""
        if color:
            self.set_text_color(*color)
        self._set_font(style, size)
        self.set_xy(x, y)
        # FPDF2 can handle emojis directly if font supports Unicode
        self.cell(0, size + 2, text)
    
    def _calculate_optimal_font_size(self, text, available_width, available_height, min_size=8, max_size=30):
        """Calculate optimal font size to fill available space"""
        best_size = min_size
        
        for size in range(min_size, max_size + 1):
            # Estimate text height with this font size
            lines = len(text) / (available_width / (size * 0.6))  # Rough character width estimation
            line_height = size * 1.2  # Leading
            total_height = lines * line_height
            
            if total_height <= available_height:
                best_size = size
            else:
                break
                
        return max(best_size, min_size)
        
    def create_title_page(self, market="Unknown", job_count=0, coach_name=""):
        """Create a beautiful title page with highway background and FreeWorld branding"""
        from datetime import datetime
        
        # Persist context for later link tagging
        try:
            self.current_market = market
            self.coach_name = coach_name or ''
        except Exception:
            pass
        self.add_page()
        
        # Add highway background image (full page coverage)
        # Handle multiple deployment environments
        highway_paths = [
            # Streamlit Cloud deployment
            os.path.join(os.path.dirname(__file__), "data", "highway_background.jpg"),
            # PyInstaller bundle
            os.path.join(sys._MEIPASS, "data", "highway_background.jpg") if hasattr(sys, '_MEIPASS') else None,
            # Local development - parent directory
            os.path.join(os.path.dirname(os.path.dirname(__file__)), "data", "highway_background.jpg"),
            # Asset directory
            os.path.join(os.path.dirname(__file__), "assets", "highway_background.jpg")
        ]
        
        highway_loaded = False
        for highway_path in highway_paths:
            if highway_path and os.path.exists(highway_path):
                try:
                    # Cover entire page with highway image
                    self.image(highway_path, 0, 0, 375, 750)
                    print(f"‚úÖ Added highway background: {highway_path}")
                    highway_loaded = True
                    break
                except Exception as e:
                    print(f"‚ö†Ô∏è Could not load highway from {highway_path}: {e}")
                    continue
        
        
        # Large FreeWorld wordmark at the top with light gray background
        # Handle multiple deployment environments for wordmark
        wordmark_paths = [
            # Streamlit Cloud deployment
            os.path.join(os.path.dirname(__file__), "data", "FW-Wordmark-Roots@3x.png"),
            # PyInstaller bundle
            os.path.join(sys._MEIPASS, "data", "FW-Wordmark-Roots@3x.png") if hasattr(sys, '_MEIPASS') else None,
            # Local development
            os.path.join(os.path.dirname(os.path.dirname(__file__)), "data", "FW-Wordmark-Roots@3x.png"),
            # Asset directory
            os.path.join(os.path.dirname(__file__), "assets", "FW-Wordmark-Roots@3x.png")
        ]
        
        logo_added = False
        for wordmark_path in wordmark_paths:
            if wordmark_path and os.path.exists(wordmark_path):
                try:
                    # Large wordmark at top - maintain proper aspect ratio
                    # Calculate proportional dimensions (the wordmark is very wide)
                    wordmark_width = 300  # Wide enough for "FreeWorld"
                    wordmark_height = 40   # Proper aspect ratio - wordmarks are typically much wider than tall
                    wordmark_x = (375 - wordmark_width) / 2
                    wordmark_y = 110  # Top positioning
                    
                    # Add the wordmark directly on the highway background
                    self.image(wordmark_path, wordmark_x, wordmark_y, wordmark_width, wordmark_height)
                    print(f"‚úÖ Added FreeWorld wordmark: {wordmark_path}")
                    logo_added = True
                    break
                except Exception as e:
                    print(f"‚ö†Ô∏è Could not add wordmark {wordmark_path}: {e}")
                    continue
        
        if not logo_added:
            # Fallback to round logo with light gray background
            # Handle multiple deployment environments for fw_logo
            fw_logo_paths = [
                # Streamlit Cloud deployment
                os.path.join(os.path.dirname(__file__), "data", "fw_logo.png"),
                # PyInstaller bundle
                os.path.join(sys._MEIPASS, "data", "fw_logo.png") if hasattr(sys, '_MEIPASS') else None,
                # Local development
                os.path.join(os.path.dirname(os.path.dirname(__file__)), "data", "fw_logo.png"),
                # Asset directory
                os.path.join(os.path.dirname(__file__), "assets", "fw_logo.png")
            ]
            
            for fw_logo_path in fw_logo_paths:
                if fw_logo_path and os.path.exists(fw_logo_path):
                    try:
                        logo_size = 80
                        logo_x = (375 - logo_size) / 2
                        logo_y = 120
                    
                        # Add the round logo directly on the highway background
                        self.image(fw_logo_path, logo_x, logo_y, logo_size, logo_size)
                        print(f"‚úÖ Added FreeWorld round logo: {fw_logo_path}")
                        logo_added = True
                        break
                    except Exception as e:
                        print(f"‚ö†Ô∏è Could not add round logo: {e}")
                        continue
        
        # Smaller overlay just for the title and date area
        overlay_y = 380  # Start lower, after logo
        overlay_height = 140  # Standard height (no coach line needed)
        self.set_fill_color(0, 71, 81)  # FW Roots color (solid)
        self.rect(20, overlay_y, 335, overlay_height, 'F')  # Smaller, centered overlay
        
        # Title: "{Market} Jobs Report" 
        title_y = overlay_y + 20
        self.set_xy(40, title_y)
        title_text = f"{market} Jobs Report"
        
        # Auto-size title font to fit in the available width (295pt)
        max_font_size = 32
        min_font_size = 16
        available_width = 295
        
        # Find the optimal font size
        optimal_font_size = max_font_size
        for font_size in range(max_font_size, min_font_size - 1, -1):
            self._set_font('B', font_size)
            
            text_width = self.get_string_width(title_text)
            if text_width <= available_width - 10:  # Leave 10pt margin
                optimal_font_size = font_size
                break
        
        # Apply the optimal font size
        self._set_font('B', optimal_font_size)
        
        self.set_text_color(255, 255, 255)  # White text
        self.cell(295, 40, title_text, align='C')
        
        # Generated date
        date_y = title_y + 50
        self.set_xy(40, date_y)
        self._set_font('', 16)
        self.set_text_color(255, 255, 255)  # White text
        
        current_date = datetime.now().strftime("%B %d, %Y")
        date_text = f"Generated {current_date}"
        self.cell(295, 20, date_text, align='C')
        
        # Job count if provided
        if job_count > 0:
            count_y = date_y + 30
            self.set_xy(40, count_y)
            self._set_font('', 14)
            self.set_text_color(205, 249, 92)  # FW Freedom Green
            count_text = f"{job_count} Quality Jobs Found"
            self.cell(295, 20, count_text, align='C')
        
        # Coach name section removed - no longer displaying coach name on PDFs
        
        print(f"‚úÖ Created title page for {market} with {job_count} jobs")

    def create_job_card(self, job, job_number=None, total_jobs=None):
        """Create a single job card using FPDF2"""
        self.add_page()
        
        # Draw full-page border (2pt thick)
        self.set_draw_color(*self.fw_card_border)
        self.set_line_width(2)
        self.rect(0, 0, 375, 750, 'D')  # Full page border
        
        # Fill background
        self.set_fill_color(*self.fw_card_bg)
        self.rect(2, 2, 371, 746, 'F')  # Background inside border
        
        # Content area inside border (with padding)
        content_x = 12
        content_width = 375 - 24  # 12pt padding on each side
        
        # === FIXED HEADER SECTION ===
        y = 12
        
        # Job Title (auto-sized, teal, custom font) - use canonical mapping
        pdf_data = prepare_pdf_data(job)
        job_title = self._sanitize_text(pdf_data['job_title'])
        
        # Auto-size job title to fit available width
        max_font_size = 18
        min_font_size = 12
        title_font_size = max_font_size
        
        # Test title width and reduce font size if needed
        while title_font_size >= min_font_size:
            self._set_font('B', title_font_size)
            title_width = self.get_string_width(job_title)
            if title_width <= content_width - 10:  # 10pt padding
                break
            title_font_size -= 1
            
        self.set_text_color(*self.fw_roots)
        self.set_xy(content_x, y)
        self.cell(content_width, 24, job_title, new_x=XPos.LMARGIN, new_y=YPos.NEXT)
        y += 30
        
        # Badge Row: Match Quality + Fair Chance (if applicable)
        badge_row_y = y
        current_x = content_x
        
        # Match Quality Badge (color-coded by quality)
        # Check multiple possible column names for job classification
        match_quality = pdf_data['match'] or 'unknown'
        
        
        # Only show match badges for good and so-so matches
        if match_quality == 'good':
            match_text = "Excellent Match"
            self.set_fill_color(*self.fw_freedom_green)  # Light green for excellent match
            self.set_text_color(*self.fw_midnight)  # Midnight text
            self._set_font('B', 12)
            self.set_xy(current_x, badge_row_y)
            match_badge_width = self.get_string_width(match_text) + 24
            self.cell(match_badge_width, 24, match_text, fill=True)
            current_x += match_badge_width + 8  # 8pt gap between badges
        elif match_quality == 'so-so': 
            match_text = "Possible Fit"
            self.set_fill_color(244, 244, 244)  # Horizon grey background (FW brand color)
            self.set_text_color(*self.fw_midnight)  # Midnight text
            self._set_font('B', 12)
            self.set_xy(current_x, badge_row_y)
            match_badge_width = self.get_string_width(match_text) + 24
            self.cell(match_badge_width, 24, match_text, fill=True)
            current_x += match_badge_width + 8  # 8pt gap between badges
        # No badge for bad/unknown matches - remove the fallback entirely
        
        # Fair Chance Badge (only if fair_chance_employer)
        fair_chance_raw = pdf_data['fair_chance']
        fair_chance = str(fair_chance_raw).lower() if fair_chance_raw is not None and str(fair_chance_raw).strip() else ''
        if 'fair_chance_employer' in fair_chance:
            # Set font first to get accurate text width measurement
            self._set_font('B', 12)
            
            fair_chance_text = "Fair Chance Employer"
            fair_chance_width = self.get_string_width(fair_chance_text) + 24
            
            # Ensure badge doesn't overflow content area
            if current_x + fair_chance_width <= content_x + content_width:
                self.set_fill_color(*self.fw_roots)  # FreeWorld primary teal for fair chance
                self.set_text_color(255, 255, 255)  # White text for contrast
                self.set_xy(current_x, badge_row_y)
                self.cell(fair_chance_width, 24, fair_chance_text, fill=True)
                current_x += fair_chance_width + 8  # 8pt gap between badges

        # Career Pathway Badge (new feature)
        career_pathway = pdf_data.get('career_pathway', '')
        training_provided = pdf_data.get('training_provided', False)

        if career_pathway and career_pathway not in ['', 'unknown', 'general_warehouse', 'no_pathway']:
            # Import badge factory for pathway badges
            from branded_badge_system import BadgeFactory

            # Set font first to get accurate text width measurement
            self._set_font('B', 12)

            # Create pathway badge with appropriate styling
            if career_pathway == 'dock_to_driver':
                pathway_text = "DOCK TO DRIVER"
                self.set_fill_color(*self.fw_freedom_green)  # Green for excellent pathways
                self.set_text_color(*self.fw_midnight)
            elif career_pathway == 'internal_cdl_training':
                pathway_text = "CDL TRAINING PROVIDED"
                self.set_fill_color(*self.fw_freedom_green)  # Green for excellent pathways
                self.set_text_color(*self.fw_midnight)
            elif career_pathway == 'warehouse_to_driver':
                pathway_text = "WAREHOUSE TO DRIVER"
                self.set_fill_color(*self.fw_freedom_green)  # Green for good pathways
                self.set_text_color(*self.fw_midnight)
            elif career_pathway == 'logistics_progression':
                pathway_text = "LOGISTICS CAREER PATH"
                self.set_fill_color(*self.fw_visionary_violet)  # Purple for possible pathways
                self.set_text_color(*self.fw_midnight)
            elif career_pathway == 'non_cdl_driving':
                pathway_text = "NON-CDL DRIVING"
                self.set_fill_color(*self.fw_visionary_violet)  # Purple for possible pathways
                self.set_text_color(*self.fw_midnight)
            elif career_pathway == 'stepping_stone':
                pathway_text = "STEPPING STONE"
                self.set_fill_color(255, 204, 0)  # Yellow for conditional pathways
                self.set_text_color(*self.fw_midnight)
            else:
                pathway_text = career_pathway.replace('_', ' ').upper()
                self.set_fill_color(244, 244, 244)  # Grey for default
                self.set_text_color(*self.fw_midnight)

            pathway_width = self.get_string_width(pathway_text) + 24

            # Ensure badge doesn't overflow content area
            if current_x + pathway_width <= content_x + content_width:
                self.set_xy(current_x, badge_row_y)
                self.cell(pathway_width, 24, pathway_text, fill=True)
        
        y += 24
        
        # Company only (location moved to metadata section)
        company = self._sanitize_text(pdf_data['company'])
        self.set_text_color(*self.fw_midnight)
        self._set_font('B', 10)
        self.set_xy(content_x, y)
        self.cell(content_width, 14, company, new_x=XPos.LMARGIN, new_y=YPos.NEXT)
        y += 18
        
        # Metadata rows
        self._set_font('', 10)
        metadata_items = []
        
        # Add salary if available - DISABLED per user request
        # salary_text = self._get_conditional_salary_text(job)
        # if salary_text:
        #     metadata_items.append(f"Salary: {salary_text}")
            
        # Add location (moved above route type)
        location = self._sanitize_text(pdf_data['location'])
        if location:
            metadata_items.append(location)
            
        # Add route type if available (no prefix, hide if Unknown)
        route_type = pdf_data['route_type']
        # Handle empty/NaN/Unknown values - don't display if not meaningful
        if route_type and str(route_type).lower() not in ['unknown', 'nan', '', 'none'] and str(route_type).strip():
            metadata_items.append(str(route_type))
        
        # Display metadata rows
        for metadata in metadata_items:
            self.set_xy(content_x, y)
            self.cell(content_width, 12, metadata, new_x=XPos.LMARGIN, new_y=YPos.NEXT)
            y += 16
        
        # === OPTIMIZED SUMMARY SECTION ===
        # Get AI summary text
        summary_text = pdf_data['summary']
        reason_text = pdf_data['reason']
        
        # Check if summary is valid (substantial content, not identical to reason)
        if (summary_text and 
            str(summary_text).strip() and 
            len(str(summary_text).strip()) >= 50 and
            str(summary_text).strip().lower() != str(reason_text).strip().lower()):
            # Use the AI summary
            clean_summary = self._sanitize_text(summary_text).replace('\n', ' ').replace('\r', '')
        else:
            # Use clean summary text
            clean_summary = "Exciting opportunity awaiting. Click below to view full details and apply directly."
        
        # Calculate available space for summary - USE ALL AVAILABLE SPACE
        metadata_end_y = y  # Current Y position after all metadata
        apply_section_height = 100  # Fixed height for apply section + link + counter
        max_summary_height = 750 - apply_section_height - metadata_end_y - 16  # 16pt total padding
        
        # Use adaptive font size to fill available space optimally
        summary_font_size = 16  # Start with good readable size
        line_height = summary_font_size + 4  # Increased line spacing for readability
        
        # Set font for measurement
        self._set_font('', summary_font_size)
        
        # Calculate available space and text requirements
        summary_width = content_width - 12  # Account for padding
        summary_height = max_summary_height
        summary_start_y = metadata_end_y + 8
        
        # Draw summary background (white)
        self.set_fill_color(255, 255, 255)  # White background
        self.rect(content_x, summary_start_y, content_width, summary_height, 'F')
        
        # DYNAMIC FONT SIZING to fill ALL available space
        self.set_text_color(*self.fw_midnight)
        
        # Start with a reasonable font size and scale UP to fill the space
        test_font_size = 8  # Start small
        max_font_size = 24  # Reasonable upper limit
        best_font_size = test_font_size
        best_lines = []  # Initialize to prevent errors
        best_line_height = test_font_size * 1.4  # Initialize to prevent errors
        
        # Binary search to find the largest font size that fits perfectly
        while test_font_size <= max_font_size:
            self._set_font('', test_font_size)
            
            # Calculate how many lines this font size will need
            words = clean_summary.split()
            lines = []
            current_line = ""
            
            for word in words:
                test_line = current_line + (" " if current_line else "") + word
                if self.get_string_width(test_line) <= summary_width - 12:
                    current_line = test_line
                else:
                    if current_line:
                        lines.append(current_line)
                    current_line = word
            if current_line:
                lines.append(current_line)
            
            # Calculate required height with proper line spacing
            line_height = test_font_size * 1.4  # Good line spacing ratio
            required_height = len(lines) * line_height
            
            # If it fits in available space, this font size works
            if required_height <= max_summary_height:
                best_font_size = test_font_size
                best_lines = lines
                best_line_height = line_height
                test_font_size += 1  # Try larger
            else:
                break  # Too big, use previous size
        
        # Use the largest font size that fits
        self._set_font('', best_font_size)
        
        # Safety check: if no lines fit, create minimal content
        if not best_lines and clean_summary:
            best_lines = [clean_summary[:50] + "..." if len(clean_summary) > 50 else clean_summary]
        
        # If we still have extra space, increase line spacing to fill it
        if len(best_lines) > 0:
            used_height = len(best_lines) * best_line_height
            if used_height < max_summary_height:
                # Stretch line spacing to use remaining space
                best_line_height = max_summary_height / len(best_lines)
        
        # Draw each line with the optimized font size and spacing
        for i, line in enumerate(best_lines):
            line_y = summary_start_y + 8 + (i * best_line_height)
            self.set_xy(content_x + 6, line_y)
            self.cell(summary_width, best_line_height, line, align='L')
        
        
        # === FIXED APPLY SECTION AT BOTTOM ===
        apply_y = 750 - apply_section_height
        
        # Horizon grey background for apply section (FreeWorld Horizon Grey)
        self.set_fill_color(*self.fw_horizon_grey)
        self.rect(0, apply_y, 375, apply_section_height, 'F')
        
        # Apply button that looks like a real button with shadow/border
        button_y = apply_y + 8
        button_height = 32
        button_margin = 20  # Margins on left/right to make button narrower
        button_width = content_width - (button_margin * 2)
        button_x = content_x + button_margin
        
        # Draw button (light green only, no shadow)
        self.set_fill_color(*self.fw_freedom_green)  # Light green button
        self.set_draw_color(*self.fw_midnight)  # Dark border
        self.set_line_width(1.5)
        self.rect(button_x, button_y, button_width, button_height, 'DF')  # Draw and Fill
        
        # Load FreeWorld logo
        try:
            # Try different logo files - prioritize the round FreeWorld logo
            # Handle both development and PyInstaller bundled paths
            if hasattr(sys, '_MEIPASS'):
                logo_paths = [
                    os.path.join(sys._MEIPASS, "data", "fw_logo.png"),
                    os.path.join(sys._MEIPASS, "data", "FW-Logo-Roots@2x.png"),
                    os.path.join(sys._MEIPASS, "data", "FW-Wordmark-Roots@3x.png")
                ]
            else:
                # Try multiple possible paths for logo files
                current_dir = os.path.dirname(__file__)
                logo_paths = [
                    os.path.join(current_dir, "data", "fw_logo.png"),
                    os.path.join(current_dir, "data", "FW-Logo-Roots@2x.png"), 
                    os.path.join(current_dir, "assets", "fw_logo.png"),
                    os.path.join(current_dir, "assets", "FW-Logo-Roots@2x.png"),
                    "/workspaces/freeworld-success-coach-portal/data/fw_logo.png",
                    "/workspaces/freeworld-success-coach-portal/data/FW-Logo-Roots@2x.png"
                ]
            
            logo_loaded = False
            for logo_path in logo_paths:
                if os.path.exists(logo_path):
                    # Calculate centered positioning for logo + text
                    logo_height = 20
                    logo_width = 20  # Round logo is square
                    text = "APPLY NOW"
                    
                    # Set font to calculate text width
                    self._set_font('B', 14)
                    font_used = 'Palatino'
                    
                    text_width = self.get_string_width(text)
                    spacing = 8  # Space between logo and text
                    total_content_width = logo_width + spacing + text_width
                    
                    # Center the combined logo + text within button
                    content_start_x = button_x + (button_width - total_content_width) / 2
                    
                    # Position logo centered vertically and horizontally
                    logo_x = content_start_x
                    logo_y = button_y + (button_height - logo_height) / 2
                    
                    self.image(logo_path, logo_x, logo_y, logo_width, logo_height)
                    
                    # Position text next to logo, centered vertically
                    text_x = logo_x + logo_width + spacing
                    text_y = button_y + (button_height - 14) / 2  # Center text vertically
                    
                    # Get URL for linking
                    apply_url = pdf_data['apply_url']
                    tracked_url = pdf_data['tracked_url'] or self._create_tracked_url(job)
                    final_url = tracked_url if tracked_url and tracked_url != apply_url else apply_url
                    
                    # Add clickable text (same color whether clickable or not)
                    self.set_xy(text_x, text_y)
                    self.set_text_color(*self.fw_midnight)  # Keep original dark color
                    if final_url:
                        self.cell(text_width, 14, text, align='L', link=final_url)
                    else:
                        self.cell(text_width, 14, text, align='L')
                    
                    logo_loaded = True
                    break
            
            if not logo_loaded:
                # Clean text button fallback only if no logo was loaded
                self.set_xy(button_x, button_y + 10)
                self._set_font('B', 16)
                
                # Get the URL to use for the link
                apply_url = pdf_data['apply_url']
                tracked_url = pdf_data['tracked_url'] or self._create_tracked_url(job)
                final_url = tracked_url if tracked_url and tracked_url != apply_url else apply_url
                
                # Keep original dark text color for consistency
                self.set_text_color(*self.fw_midnight)
                if final_url:
                    self.cell(button_width, 12, "APPLY NOW", align='C', link=final_url)
                else:
                    self.cell(button_width, 12, "APPLY NOW", align='C')
        
        except Exception as e:
            # Text-only button fallback
            self.set_xy(button_x, button_y + 10)
            self._set_font('B', 16)
            self.set_text_color(*self.fw_midnight)
            apply_url = pdf_data['apply_url']
            if apply_url:
                self.cell(button_width, 12, "APPLY NOW", align='C', link=apply_url)
            else:
                self.cell(button_width, 12, "APPLY NOW", align='C')
        
        # Link display below button: show the actual short URL if available, else the apply URL
        apply_url = pdf_data['apply_url']
        tracked_url = pdf_data['tracked_url'] or self._create_tracked_url(job)

        # Determine display/link targets
        display_link = tracked_url or apply_url
        display_text = str(display_link or '').replace('nan', '') if display_link else ''

        if display_text:
            self.set_xy(content_x, button_y + button_height + 8)  # Position below button
            self._set_font('', 10)
            self.set_text_color(*self.fw_midnight)
            # Render the exact short link if present, otherwise the full apply URL
            self.cell(content_width, 10, display_text, align='C', link=display_link)
        
        # Job counter at very bottom
        self.set_xy(content_x, apply_y + 75)
        self._set_font('', 9)
        self.set_text_color(*self.fw_midnight)
        counter_text = f"Job {job_number or 1} of {total_jobs or 1}"
        self.cell(content_width, 10, counter_text, align='C')
    
    def _get_conditional_salary_text(self, job):
        """Get salary text if available"""
        pdf_data = prepare_pdf_data(job)
        return pdf_data['salary'] if pdf_data['salary'] else ""
        
    def _get_fair_chance_text(self, job):
        """Get fair chance policy text"""
        pdf_data = prepare_pdf_data(job)
        fair_chance_raw = pdf_data['fair_chance']
        fair_chance = str(fair_chance_raw).lower() if fair_chance_raw is not None and str(fair_chance_raw).strip() else ''
        if 'fair_chance_employer' in fair_chance:
            return "Fair Chance Employer"
        elif 'no_requirements_mentioned' in fair_chance:
            return "Background Check Policy Not Specified"
        elif 'background_check_required' in fair_chance:
            return "Background Check Required"
        elif fair_chance and fair_chance not in ['unknown', 'nan', '', 'n/a']:
            return fair_chance.replace('_', ' ').title()
        return None
        
    def _get_endorsement_text(self, job):
        """Get CDL endorsement requirements"""
        pdf_data = prepare_pdf_data(job)
        endorsements_raw = pdf_data['endorsements']
        endorsements = str(endorsements_raw).lower() if endorsements_raw is not None and str(endorsements_raw).strip() else ''
        if 'hazmat' in endorsements:
            return "HAZMAT Endorsement Required"
        elif 'passenger' in endorsements:
            return "Passenger Endorsement Required"
        elif 'school_bus' in endorsements:
            return "School Bus Endorsement Required"
        elif 'tanker' in endorsements:
            return "Tanker Endorsement Required"
        elif 'double_triple' in endorsements:
            return "Double/Triple Endorsement Required"
        elif 'none_required' in endorsements:
            return "No Special Endorsements Required"
        elif endorsements and endorsements not in ['unknown', 'nan', '', 'n/a']:
            return endorsements.replace('_', ' ').title() + " Required"
        return None
        
    def _create_tracked_url(self, job):
        """Create tracked URL using unified agent tracking approach from free_agent_system"""
        pdf_data = prepare_pdf_data(job)
        apply_url = pdf_data['apply_url']
        if not apply_url:
            return None
        
        # First try to use the unified tracking function for consistency
        try:
            from free_agent_system import update_job_tracking_for_agent
            import pandas as pd
            
            # Build agent params matching free_agent_system format
            agent_params = {
                'coach_username': getattr(self, 'coach_username', '') or '',
                'location': getattr(self, 'current_market', 'Unknown'),
                'route_filter': str(pdf_data['route_type'] or '').lower() or 'unknown',
                'fair_chance_only': 'fair_chance_employer' in str(pdf_data['fair_chance'] or '').lower(),
                'agent_uuid': getattr(self, 'candidate_id', ''),
                'agent_name': getattr(self, 'candidate_name', '')
            }
            
            # Create single-row DataFrame for this job
            job_df = pd.DataFrame([{
                'source.url': apply_url,
                'source.title': pdf_data['job_title'],
                'ai.match': str(pdf_data['match'] or '').lower() or 'unknown'
            }])
            
            # Use unified tracking function
            tracked_df = update_job_tracking_for_agent(job_df, agent_params)
            
            if not tracked_df.empty and 'meta.tracked_url' in tracked_df.columns:
                tracked_url = tracked_df.iloc[0]['meta.tracked_url']
                if tracked_url:
                    return tracked_url
                    
        except (ImportError, Exception) as e:
            if self.debug:
                print(f"  ‚ÑπÔ∏è Could not use unified tracking: {e}")
        
        # Fallback to direct implementation (matching free_agent_system logic exactly)
        job_id = pdf_data['job_id']
        try:
            if hasattr(self.link_tracker, 'create_short_link'):
                # Build tags matching free_agent_system format exactly
                tags = []
                
                # Coach tag
                coach_user = getattr(self, 'coach_username', '') or ''
                if coach_user:
                    tags.append(f"coach:{coach_user}")
                elif getattr(self, 'coach_name', ''):
                    coach_first = self.coach_name.split()[0]
                    tags.append(f"coach:{coach_first}")
                
                # Market tag
                market = getattr(self, 'current_market', 'Unknown') or 'Unknown'
                tags.append(f"market:{market}")
                
                # Route tag
                route = str(pdf_data['route_type'] or '').lower() or 'unknown'
                tags.append(f"route:{route}")
                
                # Match quality tag
                match = str(pdf_data['match'] or '').lower() or 'unknown'
                tags.append(f"match:{match}")
                
                # Fair chance tag
                fair = str(pdf_data['fair_chance'] or '').lower()
                fair_flag = 'true' if 'fair_chance_employer' in fair else 'false'
                tags.append(f"fair:{fair_flag}")
                
                # Candidate tag (matching free_agent_system format)
                cand_id = getattr(self, 'candidate_id', '') or ''
                if cand_id:
                    tags.append(f"candidate:{cand_id}")
                
                title = pdf_data['job_title'].strip()
                return self.link_tracker.create_short_link(apply_url, title=title, tags=tags)
            elif hasattr(self.link_tracker, 'create_tracked_link'):
                return self.link_tracker.create_tracked_link(apply_url, job_id)
            elif hasattr(self.link_tracker, 'create_link'):
                return self.link_tracker.create_link(apply_url, job_id)
            else:
                return apply_url
        except Exception as e:
            print(f"  ‚ö†Ô∏è Link tracking failed: {e}")
            return apply_url

def generate_fpdf_job_cards(jobs_df, output_path, market="Unknown", coach_name:"str"="", coach_username:"str"="", candidate_name:"str"="", candidate_id:"str"="", show_prepared_for:bool=True):
    """Generate job cards using FPDF2 with beautiful title page"""
    
    
    # Read coach/candidate info from DataFrame if available (preferred method)
    # ALWAYS extract names for tracking/analytics, regardless of show_prepared_for
    if len(jobs_df) > 0:
        # Prefer canonical agent.* fields; fall back to legacy meta.*
        df_coach_name_agent = jobs_df.get('agent.coach_name', pd.Series()).iloc[0] if 'agent.coach_name' in jobs_df.columns else ""
        df_coach_username_agent = jobs_df.get('agent.coach_username', pd.Series()).iloc[0] if 'agent.coach_username' in jobs_df.columns else ""
        df_candidate_name_agent = jobs_df.get('agent.name', pd.Series()).iloc[0] if 'agent.name' in jobs_df.columns else ""
        df_candidate_id_agent = jobs_df.get('agent.uuid', pd.Series()).iloc[0] if 'agent.uuid' in jobs_df.columns else ""

        df_coach_name_meta = jobs_df.get('meta.coach_name', pd.Series()).iloc[0] if 'meta.coach_name' in jobs_df.columns else ""
        df_coach_username_meta = jobs_df.get('meta.coach_username', pd.Series()).iloc[0] if 'meta.coach_username' in jobs_df.columns else ""
        df_candidate_name_meta = jobs_df.get('meta.candidate_name', pd.Series()).iloc[0] if 'meta.candidate_name' in jobs_df.columns else ""
        df_candidate_id_meta = jobs_df.get('meta.candidate_id', pd.Series()).iloc[0] if 'meta.candidate_id' in jobs_df.columns else ""

        # Use DataFrame values if available, otherwise use parameters  
        coach_name = (df_coach_name_agent or df_coach_name_meta or coach_name)
        coach_username = (df_coach_username_agent or df_coach_username_meta or coach_username)
        candidate_name = (df_candidate_name_agent or df_candidate_name_meta or candidate_name)
        candidate_id = (df_candidate_id_agent or df_candidate_id_meta or candidate_id)
    
    # Debug: Check what we received/extracted
    print(f"üîç PDF Generator received: {len(jobs_df)} jobs")
    print(f"   Market: '{market}'")
    print(f"   Coach: '{coach_name}' (empty={not coach_name})")
    print(f"   Coach Username: '{coach_username}' (empty={not coach_username})")  
    print(f"   Candidate: '{candidate_name}' (empty={not candidate_name})")
    print(f"   Candidate ID: '{candidate_id}' (empty={not candidate_id})")
    
    # Debug: Check DataFrame columns for metadata
    if len(jobs_df) > 0:
        meta_cols = [col for col in jobs_df.columns if col.startswith('meta.')]
        print(f"   DataFrame meta columns: {meta_cols}")
        if 'meta.candidate_name' in jobs_df.columns:
            sample_candidate = jobs_df['meta.candidate_name'].iloc[0]
            print(f"   DataFrame meta.candidate_name: '{sample_candidate}' (empty={not sample_candidate})")
    
    # Extract names for "Generated for" message - ensure strings and handle NaN values
    candidate_name_str = str(candidate_name) if candidate_name not in ['', None] and not (isinstance(candidate_name, float) and pd.isna(candidate_name)) else ""
    coach_name_str = str(coach_name) if coach_name not in ['', None] and not (isinstance(coach_name, float) and pd.isna(coach_name)) else ""
    
    agent_first_name = candidate_name_str.split()[0] if candidate_name_str and candidate_name_str.split() else ""
    coach_first_name = coach_name_str.split()[0] if coach_name_str and coach_name_str.split() else ""
    print(f"   üè∑Ô∏è  Agent first name: '{agent_first_name}' (empty={not agent_first_name})")
    print(f"   üè∑Ô∏è  Coach first name: '{coach_first_name}' (empty={not coach_first_name})")
    print(f"   üîç  Original coach_name: '{coach_name}'")
    print(f"   üîç  Extracted coach_first_name: '{coach_first_name}'")
    
    if not jobs_df.empty:
        print(f"  üìã DataFrame shape: {jobs_df.shape}")
        print(f"  üìÑ Columns: {list(jobs_df.columns)[:10]}...")  # First 10 columns
        print(f"  üìà Sample data check:")
        for col in ['job_title', 'company', 'match']:
            if col in jobs_df.columns:
                print(f"    {col}: {jobs_df[col].notna().sum()}/{len(jobs_df)} non-null")
    
    if jobs_df.empty:
        print("  ‚ùå No jobs to generate PDF for")
        return None
    
    # Clean market name for display
    # For markets: remove state abbreviation (e.g., "Dallas, TX" ‚Üí "Dallas")  
    # For custom locations: use exactly what user entered
    clean_market = market
    if market != "Unknown":
        # Check if this looks like a market with state abbreviation
        if ', ' in market and len(market.split(', ')[-1]) == 2:
            # This is likely "Market, ST" format - remove state for markets only
            # We can detect if it's a predefined market vs custom location by common patterns
            market_part = market.split(', ')[0]
            if market_part.lower() in ['dallas', 'houston', 'bay area', 'denver', 'vegas', 'newark', 'phoenix', 'stockton', 'inland empire', 'trenton']:
                clean_market = market_part
            # For custom locations, keep exactly as entered (don't modify)
        # Handle "Las Vegas" special case
        if market.lower() == 'vegas':
            clean_market = 'Las Vegas'
    
    pdf = FreeWorldJobCardFPDF()
    # Persist candidate context for tag generation
    try:
        pdf.candidate_id = candidate_id or ''
        pdf.coach_username = coach_username or ''
    except Exception:
        pass
    total_jobs = len(jobs_df)
    
    print(f"  üìÑ Creating title page and {total_jobs} job cards with FPDF2")
    
    # Sort jobs by priority: Local‚ÜíOTR‚ÜíUnknown, then by quality within each route type
    def get_sort_priority(row):
        # Route type priority (most important)
        route_type = str(row.get('ai.route_type', '')).lower()
        if route_type == 'local':
            route_priority = 0
        elif route_type in ['otr', 'regional']:
            route_priority = 1  
        else:
            route_priority = 2  # Unknown/other
        
        # Quality priority within route type
        ai_match = row.get('ai.match', '')
        fair_chance = row.get('ai.fair_chance', '').lower()
        
        is_excellent = ai_match == 'good'
        is_possible = ai_match == 'so-so'  
        has_fair_chance = 'fair_chance_employer' in fair_chance
        
        if is_excellent and has_fair_chance:
            quality_priority = 1  # Highest quality
        elif is_excellent:
            quality_priority = 2  # Second quality  
        elif is_possible and has_fair_chance:
            quality_priority = 3  # Third quality
        elif is_possible:
            quality_priority = 4  # Fourth quality
        else:
            quality_priority = 5  # Lowest quality (bad/unknown matches)
        
        # Combine: route_priority * 10 + quality_priority for proper ordering
        # This ensures Local jobs always come first, then OTR, then Unknown
        return route_priority * 10 + quality_priority
    
    # Apply sorting
    jobs_df = jobs_df.copy()
    jobs_df['_sort_priority'] = jobs_df.apply(get_sort_priority, axis=1)
    jobs_df = jobs_df.sort_values('_sort_priority').drop('_sort_priority', axis=1).reset_index(drop=True)

    # Create beautiful title page first
    pdf.create_title_page(clean_market, total_jobs, coach_name if coach_name else "",)
    # If candidate name OR coach name available AND show_prepared_for is True, draw personalization line
    if show_prepared_for and (candidate_name or coach_name):
        try:
            agent_first_name = candidate_name.split()[0] if candidate_name.split() else candidate_name
            
            # Handle coach name - could be "James" or "james.hazelton" (username format)
            if coach_name:
                if ' ' in coach_name:
                    # Space-separated format: "James Hazelton" -> "James"
                    coach_first_name = coach_name.split()[0]
                elif '.' in coach_name:
                    # Username format: "james.hazelton" -> "James"
                    coach_first_name = coach_name.split('.')[0].capitalize()
                else:
                    # Single name: "James" -> "James" or "james" -> "James"
                    coach_first_name = coach_name.capitalize()
            else:
                coach_first_name = ""
            
            # Position properly under the job count, with proper spacing
            # Calculate Y position based on existing elements
            base_y = 280  # Base position after title
            if total_jobs > 0:
                prepared_y = base_y + 100  # Space after job count
            else:
                prepared_y = base_y + 70   # Space after date if no job count
            
            pdf.set_xy(40, prepared_y)
            pdf._set_font('', 12)
            pdf.set_text_color(255, 255, 255)
            
            # Create the message based on available names
            if agent_first_name and coach_first_name:
                # Both agent and coach available
                if coach_first_name.lower().startswith('coach'):
                    line = f"Prepared for {agent_first_name} by {coach_first_name}"
                else:
                    line = f"Prepared for {agent_first_name} by Coach {coach_first_name}"
            elif agent_first_name:
                # Only agent available
                line = f"Prepared for {agent_first_name}"
            elif coach_first_name:
                # Only coach available
                if coach_first_name.lower().startswith('coach'):
                    line = f"Prepared by {coach_first_name}"
                else:
                    line = f"Prepared by Coach {coach_first_name}"
            else:
                # Neither available
                line = "Job Report"
            
            pdf.cell(295, 20, line, align='C')
        except Exception:
            pass
    
    # Create job cards (use enumerate for proper numbering)
    for job_number, (index, job) in enumerate(jobs_df.iterrows(), 1):
        pdf.create_job_card(job, job_number, total_jobs)
    
    # Save PDF - force overwrite existing files
    output_dir = os.path.dirname(output_path)
    if output_dir:  # Only create directory if there is one
        os.makedirs(output_dir, exist_ok=True)
    
    # Remove existing PDF file to ensure clean overwrite
    if os.path.exists(output_path):
        try:
            os.remove(output_path)
            print(f"  üóëÔ∏è  Removed existing PDF: {os.path.basename(output_path)}")
        except Exception as e:
            print(f"  ‚ö†Ô∏è  Could not remove existing PDF: {e}")
    
    pdf.output(output_path)
    
    # Get file size
    file_size_kb = os.path.getsize(output_path) / 1024 if os.path.exists(output_path) else 0
    
    print(f"  ‚úÖ FPDF2 PDF generated: {output_path} ({file_size_kb:.1f} KB)")
    
    return {
        'success': True,
        'output_path': output_path,
        'total_jobs': total_jobs,
        'file_size_kb': file_size_kb
    }

if __name__ == "__main__":
    # Test with sample data
    sample_job = {
        'job_title': 'HAZMAT Hot Shot Truck Driver',
        'match_level': 'good',
        'company': 'A to B Tow & Transportation',
        'location': 'Houston, TX',
        'salary_min': 600,
        'salary_max': 1800,
        'salary_unit': 'weekly',
        'route_type': 'Local',
        'fair_chance': 'fair_chance_employer',
        'endorsements': 'hazmat_required',
        'summary': '''A to B Tow & Transportation is urgently hiring HAZMAT Hot Shot Truck Drivers, with a focus on candidates who have a TWIC card and HAZMAT certification. The job offers commission-based pay and encourages individuals with criminal records to apply. This position is ideal for those with flatbed experience and offers local runs with some out-of-town work. The flexibility in hiring makes this a great opportunity for FreeWorld candidates looking to enter the trucking industry.''',
        'apply_url': 'https://example.com/apply',
        'job_id': 'test_123'
    }
    
    df = pd.DataFrame([sample_job])
    result = generate_fpdf_job_cards(df, '../data/test_fpdf_integration.pdf', 'Houston')
    print(f"  üéâ Integration test result: {result}")
